# 빠른 CPU를 위한 설계 기법
## 클럭
- CPU를 어떻게 설계해야 하는가?
    - 컴퓨터는 '클럭 신호'에 맞춰 작동
    - 클럭 신호를 빠르게 반복하기
- 실제로 클럭 속도가 높은 CPU == 성능이 좋은 CPU
- 클럭 속도: Hz(헤르츠)
    - 1초에 클럭이 몇 번 반복되는지
    - 클럭 속도만으로 CPU 성능 향상은 한계 
## 코어와 멀티코어
- 성능을 개선하는 또 다른 방법: 코어와 스레드 수 늘리기
- 코어: 전통적인 CPU의 의미
    - 명령어를 실행하는 부품
- 멀티 코어 CPU(멀티 코어 프로세서): 코어를 여러 개 포함하는 CPU
- 코어가 무작정 많다고 성능이 좋아지는 것이 아님
    - 4인분의 요리를 100명의 요리사가 만드는 것
## 스레드와 멀티 스레드
- 스레드??
    - 실행 흐름의 단위
    - 하드웨어적 스레드
    - 소프트웨어적 스레드
### 하드웨어적 스레드
- 하나의 코어가 동시에 처리하는 명령어 단위
- 멀티스레드 프로세서: 하나의 코어로 여러 명령어를 동시에 처리하는 CPU
- 하이퍼스레딩: 인텔의 멀티스레딩 기술
### 소프트웨어적 스레드
- 하나의 프로그램에서 독립적으로 실행되는 단위
- 프로그래밍 언어나 운영체제에서 사용되는 의미
### 멀티스레드 프로세서
- 설계가 매우 복잡
- 핵심: 레지스터
    - 프로그램 카운터, 스택 포인터, 메모리 버퍼 레지스터, 메모리 주소 레지스터
    - 해당 레지스터를 여러 개 포함하도록
    - 하나의 코어에 "레지스터 세트"를 여러 개
- 멀티스레드의 경우, 한 번의 하나의 명령어를 처리하는 CPU가 여러 개
    - 하드웨어 스레드를 논리 프로세서라고 부르기도 함
### 용어 정리
- 코어: 명령어를 실행할 수 있는 하드웨어 부품
- 스레드: 명령어를 실행하는 단위
- 멀티코어 프로세서: 명령어를 실행할 수 있는 부품이 CPU 안에 2개 이상
- 멀티스레드 프로세서: 하나의 코어로 여러 개의 명령어를 동시에 실행할 수 있는 CPU
# 명령어 병렬 처리 기법
## 명령어 파이프라인
- 클럭 단위로 나눈 명령어 처리 과정
    1. 명령어 인출(Instruction Fetch)
    2. 명령어 해석(Instruction Decode)
    3. 명령어 실행(Execute Instruction)
    4. 결과 저장(Write Back)
- 각 단계를 동시에 실행이 가능
    - 같은 단계를 실행은 불가능 
- 명령어 파이프라이닝: 명령어 파이프라인에 넣고 동시에 처리하는 기법
- 높은 성능
    - 특정 상황에서 성능 향상에 실패하는 경우
    - 파이프라인 위험
- 파이프라인 위험(Hazard)
    - 데이터 위험
    - 제어 위험
    - 구조적 위험
### 데이터 위험
- 명령어 간의 데이터 의존성에 의해 발생
- 예시
    - 명령어1: R1 <- R2 + R3
    - 명령어2: R4 <- R1 + R5
    - 명령어2는 명령어1에 의존적
- 데이터 의존적인 두 명령어를 동시에 실행 -> 제대로 작동하지 않음
### 제어 위험
- 분기(branch) 등으로 인한 '프로그램 카운터'의 갑작스러운 변화
- 프로그램 카운터: '현재 실행중인 명령어'의 다음 주소로 갱신
    - 실행 흐름이 바뀌어 값이 변경 -> 미리 가져와 처리중인 명령어는 폐기
- 이를 해결하기 위해 "분기 예측"이라는 기술 사용
### 구조적 위험
- 서로 다른 명령어가 동시에 ALU, 레지스터 등과 같은 CPU 부품을 사용하려 할 때
- 자원 위험이라고도 함
## 슈퍼스칼라
- 슈퍼스칼라: CPU 내부에 여러 개의 명령어 파이프라인을 포함한 구조
- 슈퍼스칼라 프로세서(CPU): 슈퍼스칼라 구조로 명령어 처리가 가능한 CPU
- 이론적으로, 파이프라인 개수에 비례하여 프로그램 처리속도가 빨라짐
    - 파이프라인 위험 등의 문제로 실제로 비례하진 않음
    - 고도의 설계가 필요
## 비순차적 명령어 처리(OoOE)
- 오늘날 CPU 성능 향상에 크게 기여한 기법
- 대부분의 CPU가 차용
- 명령어를 순차적으로 실행하지 않음
- 명령어 코드 중, 서로 데이터 의존성이 존재하지 않는 명령어가 존재
    - 순서를 바꾸어도 무방한 명령어를 먼저 실행
    - 파이프라인이 멈추는 것을 방지하는 명령어 처리 기법
- 어떤 명령어들이 데이터 의존성을 갖는지, 순서를 바꾸어도 되는지에 대한 판단이 필요
# CISC와 RISC
## 명령어 집합
- CPU가 이해할 수 있는 명령어들의 모음
    - 명령어 집합 구조(ISA; 이하 ISA)
- CPU마다 ISA가 다를 수 있음
    - ISA가 다르다 -> 명령어가 다르다
    - 명령어가 다르다 -> 어셈블리어도 다르다
- ISA가 같은 CPU는 서로의 명령어를 이해, 다르면 이해 못함
    - 일종의 CPU의 언어
- ISA가 달라지면 달라지는 것들
    - 명령어의 구조
    - 제어 장치가 명령어를 해석하는 방식
    - 사용되는 레지스터의 종류와 개수
    - 메모리 관리 방법 등
    - 결과적으로 CPU 하드웨어 설계에 큰 영향
- 현재 ISA의 양대 산맥
    - CISC
    - RISC
## CISC (Complex Instruction Set Computer)
- 직역: 복잡한 명령어 집합을 활용하는 컴퓨터
- 가변 길이 명령어 활용
    - 명령어의 형태와 크기가 다양
- 상대적으로 적은 수의 명령어로 프로그램 실행이 가능
    - 메모리 공간 절약 가능
    - 메모리를 아끼며 개발해야 했던 시기에 인기
- 단점
    - 명령어가 복잡하고 다양한 기능 제공
        - 대다수의 복잡한 명령어는는 사용 빈도가 낮음
        - 전체의 20%정도가 사용된 명령어의 80%
    - 명령어의 크기, 실행까지의 시간이 일정하지 않음
        - 명령어 하나를 실행하는 데에 여러 클럭 주기 사용
    - 파이프라이닝에 방해
        - 파이프라이닝이 안된다 -> 높은 성능을 낼 수 없다
    - 위와 같은 이유로 인해 성장 한계
## RISC (Reduced Instruction Set Computer)
- CISC를 통해 얻은 교훈
    - 빠른 처리를 위해서 명령어 파이프라인을 활용; 명령어의 길이와 수행시간이 짧고 규격화
    - 자주 쓰이는 기본적인 명령어를 빠르게 
- RISC 
    - 명령어의 종류가 적음
    - 고정 길이 명령어 사용
    - 명령어가 규격화, 하나의 명령어가 1클럭 내외로 실행
    - 메모리 직접 접근 명령어를 load, store 2개로 제한
        - 메모리 접근을 최소화, 단순화
        - 대신 레지스터를 적극 활용 
        - load-store 구조라고도 함
- CISC보다 많은 명령어로 프로그램을 실행함
## 차이점 정리
- CISC
    - 복잡하고 다양한 명령어
    - 가변 길이 명령어
    - 다양한 주소 지정 방식
    - 프로그램을 이루는 명령어 수가 적음
    - 여러 클럭에 걸쳐 명령어 수행
    - 파이프라이닝하기 어려움
- RISC
    - 단순하고 적은 명령어
    - 고정 길이 명령어
    - 적은 주소 지정 방식
    - 프로그램을 이루는 명령어 수가 많음
    - 1클럭 내외로 명령어 수행
    - 파이프라이닝하기 쉬움