# 예외
## 예제
- 이전의 Vector 예제에서, 벡터 범위 바깥의 원소에 접근하고 싶다
    - Vector의 작성자는 이럴 때 어떻게 하고 싶은지 모름(Vector가 어떤 프로그램에서 사용되는지 모름)
    - Vector의 사용자는 문제를 일관되게 감지할 수 없음(사용자가 감지할 수 있다면, 애초에 범위를 벗어나지 않음)
- 범위 밖 접근이 일종의 복구하고 싶은 오류다 
    - Vector 구현자가 범위 밖 접근 시도를 감지해서 사용자에게 알림
    - 그럼 사용자가 적절한 동작을 취하겠죠?
## throw
```
double& Vector::operator[](int i)
{
    if (!(0<=i && i <size>()))
        throw out_of_range{ "Vector::operator[]" };
    return elem[i];
}
```
- `throw`
    - 예외를 발생시키는 데 사용 
    - 함수를 직,간접적으로 호출했던 함수에서 예외를 처리하는 핸들러를 찾아 제어를 넘김
    - 예제는 `out_of_range`를 처리하는 핸들러에게 제어가 넘어감
- 구현은 그 호출자의 컨텍스트로 돌아가야 할 때: 함수 호출 스택을 품
    - 예외 처리 메커니즘:
        - 예외를 처리하는 호출자에게 돌아가야 할 때, 범위와 함수를 벗어남
        - 필요할 때마다 그 과정(범위와 함수를 벗어나는)에서 소멸자를 호출
```
void f(Vector& v)
{
    // ...
    try { // 이 블록에서 던지는 out_of_range 예외는 아래에 정의된 핸들러가 처리
        compute1(v);    // v나 v2의 끝을 벗어나는 접근을 시도할 수 있음  
        Vector v2 = compute2(v);
        compute3(v2);
    }
    catch (const out_of_range& err) { // 여기가 핸들러
        // ... 범위 오류 처리
        cerr << err.what() << '\n';
    }
    // ...
}
```
## try
- `try` 블록: 예외 처리 코드를 작성
    - 예외가 발생할 가능성이 있는 코드 
    - 예외가 발생하면, 제어가 즉시 `catch` 블록으로 넘어감 
    - compute1, 2, 3: 범위 오류를 미리 감지하기 어려운 코드를 표현 
- `catch` 블록
    - 던져진 예외를 처리하기 위해 사용 
    - 예제: out_of_range 타입의 예외를 처리
    - 예외를 처리하기에 f()가 부적절하다 -> try 블록을 사용X, f() 호출자에 전달
- `out_of_range` 타입: 표준 라이브러리 타입임

## 결론
- 예외 처리 메커니즘을 사용해 오류 처리가 더 간단해지고, 더 체계적이고, 더 읽기 쉬움
- 단, try 문을 남용해선 안됨
    - throw와 예외를 처리하는 함수 사이에서 수십 개의 함수를 호출
    - 오히려 복잡해질 가능성이 있다
    - 단순히 예외를 호출 스택 위로 전달할 수 있어야 함 