# 함수 인수와 반환값
- 함수 호출: 프로그램의 한 부분에서 다른 부분으로 정보 전달
    - 주된 방법이자 권장하는 방법
    - 작업 수행에 필요한 정보를 함수 인수로 전달
    - 생성된 결과를 반환값으로 전달받음
```
int sum(const vector<int>& v){
    int s = 0;
    for (const int i : v) s += i;
    return s;
}
vector fib = {1, 2, 3, 5, 8, 13, 21};

int x = sum(fib);
```
- 함수 간 정보를 전달하는 경로
    - 함수 호출
    - 전역변수 
        - 알려진 오류의 원인 -> 사용 자제
    - 클래스 객체의 공유 상태
        - 명확한 추상을 공동으로 구현한 함수 간에만 공유
- 함수 간 정보를 전달할 때 고려할 핵심 사항
    - 객체를 복사하거나 공유하는가?
    - 객체를 공유한다면 가변인가?
    - "빈 객체"를 남기고 객체를 이동시키는가?
- 인수 전달, 값 반환의 기본 동작은 "복사" - 지나치게 자주 복사할 경우 암묵적으로 이동으로 최적화
    - 예제에서
        - `return s;` sum() 밖으로 복사 가능
        - `const vector<int>& v` 잠재적으로 아주 클 수 있음: 참조(`&`)에 의한 전달
            - `const` 사용: 인수 수정 없음
## 인수 전달
- 기본 동작: 복사
- 호출자의 환경에 따라 객체를 참조하고 싶다: 참조를 사용
```
void test(vector<int> v, vector<int>& rv)
{
    v[1] = 99;
    rv[2] = 66;
}
int main()
{
    vector fib = {1, 2, 3, 5, 8, 13, 21};
    test(fib, fib);
    cout << fib[1] << ' ' << fib[2] << '\n';
}
```
- 성능을 고려할 때
    - 값이 작다(복사 비용이 저렴하다): 복사
        - 어림잡아 "두 세 포인터 크기"
    - 값이 크다: 참조
- const 참조: 참조로 전달하지만, 값은 수정하고 싶지 않을 때
    - 빠르고 오류 가능성이 적은 보통의 잘 짜여진 코드

- 함수 인수의 기본 값: 우선되거나 단순히 가장 일반적인 값
    - 기본 함수 인수(default function argument)로 명시 가능
```
void print(int value, int base=10);

print(x, 16);
print(x, 60);
print(x);
```
- 기본 함수 인수의 간단한 작성: 기호적으로 간단한 함수 오버로딩
```
void print(int value, int base)

void print(int value)
{
    print(value, 10);
}
```
- 기본 인수를 사용: 함수 정의가 하나
    - 이해하기 쉽고 코드 크기가 감소
- 타입은 다르고 시맨틱이 같은 코드: 오버로딩을 사용
## 값 반환
- 함수 계산을 마친 결과 값을 함수 밖으로 전달하는 것
- 기본 동작: 복사
    - 마찬가지로 작은 객체에 이상적인 방법
- 참조: 함수에 지역적이지 않은 객체에 호출자가 접근할 때
    - Vector의 경우 첨자 지정(sub scripting)을 통해서 원소에 접근 가능
```
class Vector {
    public:
        // ...
        double& operator[](int i) { return elem[i]; }
    private:
        double* elem;
        // ...
};
```
    - `Vector`의 `i`번째 원소: 첨자 지정 연산자 호출과 독립적으로 존재
        - 그 참조 자체를 반환
    - 지역변수 반환:
        - 함수 반환하는 시점에 사라짐
        - 포인터나 참조를 반환해서는 안됨
- 대량의 정보를 함수 밖으로 빼는 방법?
```
Matrix operator+(const Matrix& x, const Matrix& y){
    Matrix res;
    // ... for all res[i, j], res[i, j] = x[i, j]+y[i, j] ...
    return res;
}
Matrix m1, m2;
// ...
Matrix m3 = m1+m2;
```
- Matrix는 아주 클 수 있음: 복사 비용도 클 수 있음
- operator+밖으로 이동 생성자를 Matrix에 제공
- 꼭 정의하지 않더라도 컴파일러가 종종 복사를 생략함
    - 이를 복사 생략이라고 함 

- 과거의 방법
    - 큰 객체를 포인터로 반환
    - 찾기 어려운 오류의 주범
- 함수에서 요구된 작업을 수행할 수 없음: 예외 던지기

## 반환 타입 추론
- 함수의 반환 값으로부터 반환 타입을 추론이 가능
``` auto mul(int i, double d) {return i*d;}```
- 제네릭 함수와 람다에서 편리한 방식
- 추론된 타입이 안정적인 인터페이스를 제공하지 않음
    - 주의가 필요

## 후위 반환 타입
- 현재 반환 타입: 함수 이름 앞에 두기
    - 역사적인 이유가 큼: 옛날부터 그랬으니까
- 인수를 보고 결과 타입을 결정할 필요가 있는 경우가 있음
    - 반환 타입 추론이 한 예
    - 네임스페이스, 람다, 콘셉트와 관련된 이슈가 있음
- 반환 타입 추론에서 인수 목록 뒤에 반환 타입을 추가
    - `auto`가 "나중에 반환 타입을 언급하거나 추론하겠다"로 해석
```auto mul(int i, double d) -> double {return i*d;}```
- 전통적인 전위 표시보다 논리적
    - 근데 대부분 코드는 전위 표시 사용

## 구조적 바인딩
- 기본적으로 함수 반환 값: 한개임
    - 클래스 객체를 반환함으로서 많은 값을 한번에 반환
- 구조적 바인딩: 클래스 객체의 멤버에 지역명을 부여하는 메커니즘
```
map<string, int> m;
for(const auto [key, value] : m){
    cout << "{" << key << "," << value << "}\n";
}
```
- 프라이빗 데이터가 없는 경우: 객체 내 데이터 멤버 수와 바인딩 정의의 수가 같음
    - 바인딩에 넣은 각 이름이 해당 멤버를 명명
- 구조적 바인딩을 행한다고 객체가 복사되지 않음
- 오로지 아이디어를 얼마나 잘 표현하느냐에 관련 