# 타입, 변수, 산술 연산
- 모든 이름과 식에는 타입이 존재
- 타입에 따라 그 이름이나 식에 수행할 수 있는 연산이 달라짐

## 선언
```int inch;```
- `inch`를 `int`로 명시
    - `inch`는 정수형 변수이다

- 선언(declaration)은 프로그램에게 엔티티를 알리고 타입을 명시하는 명령문
    - 타입(type)은 가능한 값 집합과 연산 집합(객체일 때)을 정의
    - 객체(object)는 어떤 타입의 값을 저장하는 메모리 영역
    - 값(value)은 타입에 따라 다르게 해석되는 비트 집합
    - 변수(variable)는 명명된 객체

- 몇 가지 기본 타입
    - `bool`
    - `char`
    - `int`
    - `double`
    - `unsigned`
    - 각 기본 타입은 하드웨어 설비에 해당
    - 각자 크기가 정해져 있음
        - 해당 타입에 저장할 수 있는 값의 범위가 다름
    - 타입의 크기는 `sizeof` 연산자로 알아낼 수 있음
    - 다른 크기의 타입을 사용하고 싶다
        - `int_32`와 같은 표준 라이브러리 타입 에일리어스를 이용

### 수
- 부동소수점이거나 정수
- 부동소수점 리터럴은 소수점이나 지수로 인식
- 정수 리터럴은 기본적으로 십진수
    - 0b, 0x, 0 과 같은 접두사로 2진수, 16진수, 8진수를 표현
- 긴 리터럴을 편하게 읽기 위해서는 작은따옴표(')를 사용
    - 3.14159'26535'89793'23846'
    - 16진수가 편하다: 0x1.921F'B544'42D1'8P+1로 표현

## 산술 연산
- 산술 연산자를 통해 기본 타입을 적절히 조절 가능
    - x+y // 덧셈
    - +x // 단항 덧셈
    - x-y // 뺄셈
    - -x // 단항 뺄셈
    - x*y // 곱셈
    - x/y // 나눗셈
    - x%y // 정수 나머지(modulo)
- 비교 연산자도 마찬가지
    - x==y // 같다
    - x!=y // 같지 않다
    - x<y // 작다
    - x>y // 크다
    - x<=y // 작거나 같다
    - x>=y // 크거나 같다
- 논리 연산자도 제공
    - x&y // 비트 논리곱(and)
    - x|y // 비트 논리합(or)
    - x^y // 비트 배타적 논리합(exclusive or)
    - ~x // 비트 보수(complement)
    - x&&y // 논리AND (Logical and)
    - x||y // 논리 OR (Logical or)
    - !x // 논리 부정 (Logical not(negation))
    - 비트 논리 연산자는 피연산자의 각 비트에 연산을 수행한 후 피연산자 타입의 결과를 반환
- C++는 할당과 산술 연산에 기본 타입을 자유롭게 섞어 사용할 수 있도록 타입 간 의미 있는 변환을 수행
```
void some_function()
{
    double d = 2.2;
    int i = 7;
    d = d+i; // 합을 d에 할당
    i = d*i; // 곱을 i에 할당. 단, double인 d*i가 int로 반올림
}
```
- 식에 일어난 변환을 일반 산술 변환(usual arithmetic conversion)
    - 목적은 피연산자를 가장 높은 정확도로 계산하는 것

- 식을 수정하는 간단한 연산자들
    - x+=y
    - ++x
    - x-=y
    - --x
    - x*=y
    - x/=y
    - x%=y
- `x.y`, `x->y`, `x(y)`, `x[y]`, `x<<y`, `x>>y`, `x&&y`, `x||y`는 왼쪽에서 오른쪽으로 평가
    - 최적화 이슈로 인해 다른 식들과 함수 인수는 평가 순서가 불확정

## 초기화
- 객체를 사용하려면 먼저 값을 넣어야 함
- C++는 초기화를 표현하는 다양한 표기법을 제공
    - = 대입 연산자
    - {} 초기자 리스트
        - {}는 정보를 잃는 변환(축소 변환)은 발생하지 않음
        - ```int i {7.8} //오류```
- 축소 변환은 = 를 사용하면 암묵적으로 적용된다
    - C 호환성에 따른 대가
- 상수는 왼쪽 초기화될 수 없음
    - 변수는 극히 드문 경우에만
- 변수는 적절한 값을 넣기 전에 이름을 사용해서는 안됨
- 사용자 정의 타입은 암묵적으로 초기화되도록 정의할 수 있음

- 변수를 정의할 때 초기자로부터 타입을 추론이 가능하다 -> 명시적 타입 작성 하지 않아도 됨
    - ```auto b = true;```: 누가봐도 boolean형
- `auto`를 사용할 때는 =를 선호
    - 골치 아픈 타입 변환이 일어날 가능성
- 타입을 명시적으로 언급할 필요가 없을 때 `auto`를 사용
    - 언급할 필요란?
        - 정의가 광범위해서 코드의 독자에게 타입을 분명히 알릴 때
        - 초기자의 타입이 분명하지 않을 때
        - 변수의 범위나 정밀도를 분명히 밝히고 싶을 때
- `auto`는 중복과 긴 타입명을 막아줌
- 제네릭 프로그래밍에게 유용