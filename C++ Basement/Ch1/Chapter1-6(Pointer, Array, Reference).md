# 포인터, 배열, 참조
## 배열과 포인터
- 배열
    - 가장 기본적인 데이터 컬렉션
    - 연속적으로 할당된 같은 타임의 원소 시퀀스
    - 기본적으로 하드웨어에서 제공
- 포인터
    - "~로의 포인터"
    - 알맞은 타입의 객체 주소가 저장

```
char v[6];
char* p;
```
- 선언에서
    - `[]`: ~의 배열
    - `*`: ~로의 포인터
- 모든 배열에 대해
    - 하한이 0
    - 배열의 크기는 상수식

```
char* p = &v[3];
char x = *p;
```
- 단항 접두사 *: "~에 담긴 내용"
- 단항 접두사 &: "~의 주소"

- 배열 원소 출력하기
```
void print2()
{
    int v[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; // 배열을 리스트로 초기화: 범위 지정 불필요 

    for (auto x : v) // 범위 기반 for문 -> C스타일 for문보다 간단한 시퀀스 
        cout << x << '\n';

    for (auto x : {10, 21, 32, 43, 54, 65})
        cout << x << '\n';
    // ...
}
```
- v 값을 x에 복사하지 않고 참조하게만 하기
```
void increment()
{
    int v[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};

    for (auto& x : v) // v 내 각 x에 1을 더한다
        ++x;
    // ...
}
```
## 참조
- 선언에서의 단항 접두사 &: ~로의 참조
    - 포인터와 비슷
    - 참조한 값에 접근할 때 접두사 *를 쓰지 않아도 됨
    - 1번 초기화하면 다른 객체를 참조하게 바꿀 수 없음
- 함수 인수를 명시할 때 유용
``` void sort(vector<double>& v);```
- 이때 `sort(my_vec)`호출 시 `my_vec`이 복사되지 않음
    - `my_vec`이 정렬됨
- 인수 수정도 안하고 복사 비용도 들이기 싫다: const 참조 사용

## 널포인터
- 역참조가 유효하려면? 포인터가 항상 객체를 가리켜야 함
- 가리키는 객체가 없다 or 어떤 객체도 사용할 수 없다(리스트 끝 같은거): `nullptr`에 할당
- 모든 포인터 타입에 `nullptr`을 공통으로 사용

- 기존의 C 스타일: 0이나 `NULL` 사용
    - 정수와 포인터간의 혼동
    - `nullptr` 사용시 이를 방지할 수 있음

- 널 참조 같은건 없음
    - 참조는 유효한 객체를 참조해야 함
    - 이를 피할 수 있지만 그러지 않도록 함